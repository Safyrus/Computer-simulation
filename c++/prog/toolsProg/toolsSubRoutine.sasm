###############
#  SUBROUTINE #
###############


# 16 BIT INTERGER COMPARE #
# param  : $AB = 1st number, $CD = 2nd number
# return : $A = compare result
SYST_16_CMP:
    MOV $F 00
    SET $J1 80 10
    SET $J2 80 11

    CMP $A $C
    AND $F $F FE
    JMP 02 :SYST_16_CMP_GREATER
    JMP 08 :SYST_16_CMP_LESSER
    CMP $B $D
    AND $F $F FE
    JMP 02 :SYST_16_CMP_GREATER
    JMP 08 :SYST_16_CMP_LESSER

    SYST_16_CMP_EQUAL:
            MOV $A 00
            JMP $F :SYST_FCT_END
    SYST_16_CMP_LESSER:
            MOV $A FF
            JMP $F :SYST_FCT_END
    SYST_16_CMP_GREATER:
            MOV $A 01
            JMP $F :SYST_FCT_END


# 16 BIT INTERGER ADDITION #
# param  : $AB = 1st number, $CD = 2nd number
# return : $AB = addition result
SYST_16_ADD:
    MOV $F 00
    SET $J1 80 10
    SET $J2 80 11

    SYST_16_ADD_STP1:
        CMP $B $D
        AND $F $F F1
        JMP 01 :SYST_16_ADD_CARRY
        JMP $F :SYST_16_ADD_STP2
    SYST_16_ADD_CARRY:
        ADD $A $A 01
    SYST_16_ADD_STP2:
        ADD $B $B $D
        ADD $A $A $C
        JMP $F :SYST_FCT_END


# 16 BIT INTERGER SHIFT #
# param  : $AB = number, $C = number of shift, $D = direction
# return : $AB = result
SYST_16_SHIFT:
    MOV $F 00
    SET $J1 80 10
    SET $J2 80 11

    CMP $D 00
    JMP 04 :SYST_16_SHIFT_LEFT
    SYST_16_SHIFT_RIGHT:
        CMP $C 00
        JMP 04 :SYST_FCT_END
        SUB $C $C 01

        DIV $B $B 02
        AND $D $A 01
        MUL $D $D 80
        ADD $B $B $D

        DIV $A $A 02

        JMP $F :SYST_16_SHIFT_RIGHT
    SYST_16_SHIFT_LEFT:
        CMP $C 00
        JMP 04 :SYST_FCT_END
        SUB $C $C 01

        MUL $A $A 02
        AND $D $B 80
        DIV $D $D 80
        ADD $A $A $D

        MUL $B $B 02

        JMP $F :SYST_16_SHIFT_LEFT


# 16 BIT INTERGER SUBSTRACTION #
# param  : $AB = 1st number, $CD = 2nd number
# return : $AB = substraction result
SYST_16_SUB:
    MOV $F 00
    SET $J1 80 10
    SET $J2 80 11

    SYST_16_SUB_STP1:
        CMP $B $D
        AND $F $F FE
        JMP 08 :SYST_16_SUB_BORROW
        JMP $F :SYST_16_SUB_STP2
    SYST_16_SUB_BORROW:
        SUB $A $A 01
    SYST_16_SUB_STP2:
        SUB $B $B $D
        SUB $A $A $C
        JMP $F :SYST_FCT_END

# FUNCTION PROLOGUE #
# param  : $AB = call adress
# return : none
SYST_FCT_PROLOGUE:
    MOV $F 00
    SET $J1 80 10
    SET $J2 80 11

    GET $C 80 00
    GET $D 80 01

    # check if end of stack part 1
    GET $E 80 02
    CMP $C $E
    AND $F $F FE
    JMP 08 :SYST_FCT_PROLOGUE_NEXT

    # check if end of stack part 2
    GET $E 80 03
    CMP $D $E
    AND $F $F FE
    JMP 08 :SYST_FCT_PROLOGUE_NEXT
    JMP $F :SYST_FCT_PROLOGUE_ERROR

    SYST_FCT_PROLOGUE_NEXT:
        # reset error reg
        MOV $E 00

        # save first part of the adress in stack
        SET $A $C $D
        CMP $D FF
        AND $F $F FE
        JMP 04 :SYST_FCT_PROLOGUE_ADD
        ADD $D $D 01

        # save last part of the adress in stack
        SET $B $C $D
        CMP $D FF
        AND $F $F FE
        JMP 04 :SYST_FCT_PROLOGUE_ADD
        ADD $D $D 01

        # refresh stack pointer
        SET $C 80 00
        SET $D 80 01
        JMP $F :SYST_FCT_END
    SYST_FCT_PROLOGUE_ADD:
            ADD $C $C 01
            JMP $F :SYST_FCT_END
    SYST_FCT_PROLOGUE_ERROR:
            MOV $E 01
            JMP $F :SYST_FCT_EPILOGUE


# FUNCTION EPILOGUE #
# param  : none
# return : none
SYST_FCT_EPILOGUE:
    MOV $F 00
    JMP $F :SYST_REG_SAVE
    GET $A 80 00
    GET $B 80 01
    CMP $B 00
    JMP 04 :SYST_FCT_EPILOGUE_SUB
    SUB $B $B 01

    GET $C $A $B
    CMP $B 00
    JMP 04 :SYST_FCT_EPILOGUE_SUB
    SUB $B $B 01
    GET $D $A $B

    SET $A 80 00
    SET $B 80 01
    SET $D 80 10
    SET $C 80 11
    JMP $F :SYST_REG_LOAD
    GET $J1 80 10
    GET $J2 80 11
    JMP $F $J1 $J2

    SYST_FCT_EPILOGUE_SUB:
            SUB $A $A 01
            JMP $F $J1 $J2


# FUNCTION ONE CALLBACK #
# param  : none
# return : none
# use    : none
SYST_FCT_END:
    GET $J1 80 10
    GET $J2 80 11
    JMP $F $J1 $J2


# FUNCTION ONE STACK PUSH #
# param  : $A val to push
# return : none
# use    : $ABCDFE
SYST_STACK_PUSH:
    MOV $F 00
    SET $J1 80 10
    SET $J2 80 11

    #compare first part
    GET $B 80 04
    GET $C 80 05
    GET $D 80 08
    CMP $B $D
    AND $F $F FE
    JMP 08 :SYST_STACK_PUSH_ADD

    #compare second part
    GET $D 80 09
    CMP $C $D
    AND $F $F FE
    JMP 08 :SYST_STACK_PUSH_ADD
    JMP $F :SYST_STACK_PUSH_FULL

    SYST_STACK_PUSH_ADD:
        SET $A $B $C
        #increment stack
        CMP $C FF
        AND $F $F FE
        JMP 04 :SYST_STACK_PUSH_ADD_INC
        SYST_STACK_PUSH_ADD_END:
        ADD $C $C 01
        SET $C 80 05
        JMP $F :SYST_FCT_END
        SYST_STACK_PUSH_ADD_INC:
            ADD $B $B 01
            SET $B 80 04
            JMP $F :SYST_STACK_PUSH_ADD_END
    SYST_STACK_PUSH_FULL:
        MOV $E 03
        JMP $F :SYST_FCT_END


# FUNCTION ONE STACK POP #
# param  : none
# return : $A val to pop
# use    : $ABCDFE
SYST_STACK_POP:
    MOV $F 00
    SET $J1 80 10
    SET $J2 80 11

    #compare first part
    GET $B 80 04
    GET $C 80 05
    GET $D 80 06
    CMP $B $D
    AND $F $F FE
    JMP 02 :SYST_STACK_POP_SUB

    #compare second part
    GET $D 80 07
    CMP $C $D
    AND $F $F FE
    JMP 02 :SYST_STACK_POP_SUB
    JMP $F :SYST_STACK_POP_EMPTY

    SYST_STACK_POP_SUB:

        #decrement stack
        CMP $C 00
        AND $F $F FE
        JMP 04 :SYST_STACK_POP_SUB_DEC
        SYST_STACK_POP_SUB_END:
        SUB $C $C 01
        SET $C 80 05
        GET $A $B $C
        JMP $F :SYST_FCT_END
        SYST_STACK_POP_SUB_DEC:
            SUB $B $B 01
            SET $B 80 04
            JMP $F :SYST_STACK_POP_SUB_END
    SYST_STACK_POP_EMPTY:
        MOV $E 04
        JMP $F :SYST_FCT_END


SYST_REG_SAVE:
    SET $A 80 12
    SET $B 80 13
    SET $C 80 14
    SET $D 80 15
    SET $E 80 16
    JMP $F $J1 $J2

SYST_REG_LOAD:
    GET $A 80 12
    GET $B 80 13
    GET $C 80 14
    GET $D 80 15
    GET $E 80 16
    JMP $F $J1 $J2


# param : $AB pos, $C color
SYST_GRAPHICS_DRAW_PIX:
    MOV $F 00
    SET $J1 80 10
    SET $J2 80 11

    SET $A 80 18
    SET $B 80 19
    SET $C 80 1A

    #y
    MOV $A 00
    
    #y<<6
    MOV $C 06
    SYST_GRAPHICS_DRAW_PIX_MUL:
        CMP $C 00
        JMP 04 :SYST_GRAPHICS_DRAW_PIX_MUL_END
        SUB $C $C 01

        MUL $A $A 02
        AND $D $B 80
        DIV $D $D 80
        ADD $A $A $D

        MUL $B $B 02

        JMP $F :SYST_GRAPHICS_DRAW_PIX_MUL
    SYST_GRAPHICS_DRAW_PIX_MUL_END:

    #adr += y<<6
    MOV $C $A
    MOV $D $B
    GET $A 80 40
    GET $B 80 41

        CMP $B $D
        AND $F $F F1
        JMP 01 :SYST_GRAPHICS_DRAW_PIX_ADD_CARRY
        JMP $F :SYST_GRAPHICS_DRAW_PIX_ADD
    SYST_GRAPHICS_DRAW_PIX_ADD_CARRY:
        ADD $A $A 01
    SYST_GRAPHICS_DRAW_PIX_ADD:
        ADD $B $B $D
        ADD $A $A $C

    #adr += x/2;
    MOV $C 00
    GET $D 80 18
    DIV $D $D 02
        CMP $B $D
        AND $F $F F1
        JMP 01 :SYST_GRAPHICS_DRAW_PIX_ADD_CARRY_2
        JMP $F :SYST_GRAPHICS_DRAW_PIX_ADD_2
    SYST_GRAPHICS_DRAW_PIX_ADD_CARRY_2:
        ADD $A $A 01
    SYST_GRAPHICS_DRAW_PIX_ADD_2:
        ADD $B $B $D
        ADD $A $A $C
    #filter = f0
    MOV $C F0
    #if(x%2==0)
    GET $D 80 18
    MOD $D $D 02
    GET $E 80 1A
    CMP $D 00
    JMP 02 :SYST_GRAPHICS_DRAW_PIX_SEND
    #{
        #filter = 0f
        MOV $C 0F
        #color << 4
        MUL $E $E 10
    #}
    SYST_GRAPHICS_DRAW_PIX_SEND:
    #pix = get adr
    GET $D $A $B
    #pix & filter
    AND $D $D $C
    #pix += color
    ADD $D $D $E
    #set pix adr
    SET $D $A $B
    #error = 0
    MOV $E 00
    JMP $F :SYST_FCT_END

