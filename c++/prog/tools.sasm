####################===[GENERAL]===#########################
#
# +--------------+
# | ver: 0.0.2.1 |
# | by : Safyrus |
# +--------------+
#
#
# Devices adresses:
#   0000 - 7FFF : DISK
#   8000 - D7FF : RAM
#   D800 - DFFF : IO
#   E000 - FFFF : VRAM
#
#
# memory map:
#    x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 xA xB xC xD xE xF
# 0x [F_P] [F_L]
# 1x [F_1] [SYSTEM_REGISTER]
# 2x
# 3x
# 4x
# 5x
# 6x
# 7x
#
#
# reg:
#      A   B   C   D   E   ... G0-G5
# usr: [ INPUT/GENERAL ]       [GENERAL/OUTPUT]
# pgr: [ INPUT/GENERAL ]       [OUTPUT FUNCTION]
#      [BACK]        [ERR]
#
#
############################################################


#####################===[ANNEX]===##########################
#
# MEMORY:
#
# F_P = Function pointer
# F_L = Function stack length (where it end)
# F_1 = Function One callback
#
#
# FUNCTION:
# SYST_... = Start of all functions of this program
# FCT1 = Function one call : meaning a function that does not call any other function and therefore only needs one variable to return to the address of the call.
#
############################################################


###############
#    INIT     #
###############
SYST_INIT:

    # var function stack size
    SET 81 80 00
    SET 00 80 01
    SET 81 80 02
    SET 07 80 03


###############
#  MAIN LOOP  #
###############
SYST_MAIN:

    JMP $F FUNC_TEST
    JMP $F FUNC_TEST_3
    JMP $F FUNC_RECURSIVE
    CMP $E 01
    JMP 04 MAIN_STOP
    MAIN_ERROR:
        JMP $F MAIN_ERROR
    MAIN_STOP:
        OFF


###############
#  FUNCTIONS  #
###############

FUNC_TEST:
    MOV $A $J1
    MOV $B $J2
    JMP $F SYST_FCT1_PROLOGUE

    MOV $G0 11
    MOV $G1 22
    JMP $F FUNC_TEST_2

    JMP $F SYST_FCT1_EPILOGUE

FUNC_TEST_2:
    MOV $A $J1
    MOV $B $J2
    JMP $F SYST_FCT1_PROLOGUE

    MOV $G2 33
    MOV $G3 44
    
    JMP $F SYST_FCT1_EPILOGUE

FUNC_TEST_3:
    MOV $A $J1
    MOV $B $J2
    JMP $F SYST_FCT1_PROLOGUE

    MOV $G4 55
    MOV $G5 66

    JMP $F SYST_FCT1_EPILOGUE

FUNC_RECURSIVE:
    MOV $A $J1
    MOV $B $J2
    JMP $F SYST_FCT1_PROLOGUE

    ADD $G0 $G0 01
    JMP $F FUNC_RECURSIVE

    JMP $F SYST_FCT1_EPILOGUE


###############
#  FUNCTIONS  #
#  ONE CALL   #
###############


# 16 BIT INTERGER COMPARE #
# param  : $AB = 1st number, $CD = 2nd number
# return : $G0 = compare result
SYST_16_CMP:
    SET $J1 80 10
    SET $J2 80 11

    CMP $A $C
    AND $F $F FE
    JMP 02 SYST_16_CMP_GREATER
    JMP 08 SYST_16_CMP_LESSER
    CMP $B $D
    AND $F $F FE
    JMP 02 SYST_16_CMP_GREATER
    JMP 08 SYST_16_CMP_LESSER

    SYST_16_CMP_EQUAL:
            MOV $G0 00
            JMP $F SYST_FCT1_END
    SYST_16_CMP_LESSER:
            MOV $G0 FF
            JMP $F SYST_FCT1_END
    SYST_16_CMP_GREATER:
            MOV $G0 01
            JMP $F SYST_FCT1_END

# 16 BIT INTERGER ADDITION #
# param  : $AB = 1st number, $CD = 2nd number
# return : $G0-1 = addition result
SYST_16_ADD:
    SET $J1 80 10
    SET $J2 80 11

    SYST_16_ADD_STP1:
        CMP $B $D
        AND $F $F F1
        JMP 01 SYST_16_ADD_CARRY1
        JMP $F SYST_16_ADD_STP2
    SYST_16_ADD_CARRY1:
        ADD $A $A 01

    SYST_16_ADD_STP2:
        ADD $B $B $D
        ADD $A $A $C
        MOV $G0 $A
        MOV $G1 $B
        JMP $F SYST_FCT1_END


# FUNCTION PROLOGUE #
# param  : $AB = call adress
# return : none
SYST_FCT1_PROLOGUE:
    SET $J1 80 10
    SET $J2 80 11

    GET $C 80 00
    GET $D 80 01

    # check if end of stack part 1
    GET $E 80 02
    CMP $C $E
    AND $F $F FE
    JMP 08 SYST_FCT1_PROLOGUE_NEXT

    # check if end of stack part 2
    GET $E 80 03
    CMP $D $E
    JMP 08 SYST_FCT1_PROLOGUE_NEXT
    JMP $F SYST_FCT1_PROLOGUE_ERROR

    SYST_FCT1_PROLOGUE_NEXT:
        # reset error reg
        MOV $E 00

        # save first part of the adress in stack
        SET $A $C $D
        CMP $D FF
        AND $F $F FE
        JMP 04 SYST_FCT1_PROLOGUE_ADD
        ADD $D $D 01

        # save last part of the adress in stack
        SET $B $C $D
        CMP $D FF
        AND $F $F FE
        JMP 04 SYST_FCT1_PROLOGUE_ADD
        ADD $D $D 01

        # refresh stack pointer
        SET $C 80 00
        SET $D 80 01
        JMP $F SYST_FCT1_END
    SYST_FCT1_PROLOGUE_ADD:
            ADD $C $C 01
            JMP $F SYST_FCT1_END
    SYST_FCT1_PROLOGUE_ERROR:
            MOV $E 01
            JMP $F SYST_FCT1_EPILOGUE


# FUNCTION EPILOGUE #
# param  : none
# return : none
SYST_FCT1_EPILOGUE:
    GET $A 80 00
    GET $B 80 01
    CMP $B 00
    JMP 04 SYT_FCT_EPILOGUE_SUB
    SUB $B $B 01

    GET $C $A $B
    CMP $B 00
    JMP 04 SYT_FCT_EPILOGUE_SUB
    SUB $B $B 01
    GET $D $A $B

    SET $A 80 00
    SET $B 80 01
    JMP $F $D $C

    SYT_FCT_EPILOGUE_SUB:
            SUB $A $A 01
            JMP $F $J1 $J2


# FUNCTION ONE CALLBACK #
# param  : none
# return : none
SYST_FCT1_END:
    GET $C 80 10
    GET $D 80 11
    JMP $F $C $D
