#==============================#
#          FUNCTIONS           #
#==============================#

# PARAM: CD: string
FCT_PRINT:
 # prologue
 SET $J1 :VAR_CALL_H
 SET $J2 :VAR_CALL_L
 JMP $F :RT_PROLOGUE

 # push registers
 JMP $F :RT_PUSHABCDE

 FCT_PRINT_LOOP:
  # Is it the end
  # of the string ?
  GET $E $C $D
  CMP $E 00
  JMP UEQ :FCT_PRINT_END

  # get the cursor
  JMP $F :SRT_GETCURS

  FCT_PRINT_SPECHAR:
  # Is it a line feed ?
  CMP $E 0A
  JMP UEQ :FCT_PRINT_LF
  # Is it a backspace ?
  CMP $E 08
  JMP UEQ :FCT_PRINT_BS

  # wait for vsync
  FCT_PRINT_VSYNC:
  JMP $F :RT_VSYNC

  # print char
  SET $E $A $B
  ADD $B $B 01
  SET 0F $A $B

  # check if vsync still on
  GET $F :VPU_STATE
  AND $F $F 01
  CMP $F 00
  AND $F $F 04
  # then continue
  JMP 00 :FCT_PRINT_NEXTCHAR
  # otherwise the char was
  # likely not print and we
  # need to reprint it
  SUB $B $B 01
  JMP $F :FCT_PRINT_VSYNC

  FCT_PRINT_NEXTCHAR:
  ADD $D $D 01
  CMP $D 01
  AND $F $F 01
  JMP 01 :FCT_PRINT_INCCURS
  ADD $C $C 01
  FCT_PRINT_INCCURS:
  JMP $F :RT_CURSINC
  JMP 00 :FCT_PRINT_LOOP
  JMP $F :FCT_SCROLLUP
  MOV $A 24
  MOV $B C0
  JMP $F :SRT_SETCURS
  JMP $F :FCT_PRINT_LOOP

  # line feed
  FCT_PRINT_LF:
  OR  $B $B 3E
  SET $B :VAR_CURS_L
  JMP $F :FCT_PRINT_NEXTCHAR

  # backspace
  FCT_PRINT_BS:
  JMP $F :RT_CURSDEC
  FCT_PRINT_BS_VSYNC:
  JMP $F :RT_VSYNC
  # print null char
  SET 00 $A $B
  ADD $B $B 01
  SET 0F $A $B
  GET $F :VPU_STATE
  AND $F $F 01
  CMP $F 00
  AND $F $F 04
  JMP 00 :FCT_PRINT_BS_END
  SUB $B $B 01
  JMP $F :FCT_PRINT_BS_VSYNC

  FCT_PRINT_BS_END:
  ADD $D $D 01
  CMP $D 01
  AND $F $F 01
  JMP 01 :FCT_PRINT_LOOP
  ADD $C $C 01
  JMP $F :FCT_PRINT_LOOP

 FCT_PRINT_END:
 # pop registers
 JMP $F :RT_POPABCDE

 # epilogue
 JMP $F :RT_EPILOGUE


# 
FCT_CMD:
 # prologue
 SET $J1 :VAR_CALL_H
 SET $J2 :VAR_CALL_L
 JMP $F :RT_PROLOGUE
 JMP $F :RT_PUSHABCDE

 # print mode
 GET $J1 :VAR_MODE
 CMP $J1 M_DEBUG
 JMP UEQ :FCT_CMD_STRDEBUG
 CMP $J1 M_PROMPT
 JMP UEQ :FCT_CMD_STRPROMPT
 CMP $J1 M_PROG
 JMP UEQ :FCT_CMD_STRPROG

 # init
 FCT_CMD_INIT:
 SET :VAR_INPUTCMD:l
  :VAR_INPUTCMDINDEX
 SET 50 :VAR_CMDRET_OP1
 SET 06 :VAR_CMDRET_OP2
 SET 08 :VAR_CMDRET_OP3
 SET 09 :VAR_CMDRET_OP4

 FCT_CMD_LOOP:
  # get device output on port 0
  GET $A :IO1G

  # ignore if it is zero
  CMP $A 01
  AND $F $F FLC
  JMP UGE :FCT_CMD_KEY

  # cursor blinking
  FCT_CMD_CURS:
  # get vram color index
  JMP $F :SRT_GETCURS
  JMP $F :RT_INC16
  MOD $A $A 40
  # choose to blink or not
  MOV $D F0
  GET $F :HW_TIME
  AND $F $F 80
  CMP $F 00
  JMP UEQ :FCT_CMD_VSYNC
  XOR $D $D FF
  # wait for vsync
  FCT_CMD_VSYNC:
  JMP $F :RT_VSYNC
  # set blinking
  SET $D $A $B
  # loop
  JMP $F :FCT_CMD_LOOP

  FCT_CMD_KEY:
  MOV $D $A
  JMP $F :SRT_GETCURS
  JMP $F :RT_INC16
  MOD $A $A 40
  JMP $F :RT_VSYNC
  SET 0F $A $B
  MOV $A $D

  SET $A :VAR_KEYCHAR
  SET 00 :VAR_KEYCHARSTOP
  # Is it escape ?
  CMP $A K_ESC
  JMP UEQ :FCT_CMD_END
  # Is it a cariage return ?
  CMP $A K_CR
  JMP UEQ :FCT_CMD_CR
  # Is it a backspace ?
  CMP $A K_BS
  JMP UEQ :FCT_CMD_BS
  # Is the cmd full ?
  GET $J1 :VAR_INPUTCMDINDEX
  GET $J2 :VAR_MAXCMDBUF
  SUB $F :VAR_INPUTCMDSTOP:l $J2
  CMP $J1 $F
  JMP UEQ :FCT_CMD_LOOP

  # save key
  FCT_CMD_SAVE:
  GET $F :VAR_INPUTCMDINDEX
  SET $A :VAR_INPUTCMD:h $F
  ADD $F $F 01
  SET $F :VAR_INPUTCMDINDEX
  MOV $C $D :VAR_KEYCHAR
  JMP $F :FCT_PRINT
  JMP $F :FCT_CMD_LOOP

  # backspace
  FCT_CMD_BS:
  GET $F :VAR_INPUTCMDINDEX
  CMP $F :VAR_INPUTCMD:l
  JMP UEQ :FCT_CMD_LOOP
  GET $F :VAR_INPUTCMDINDEX
  SET 00 :VAR_INPUTCMD:h $F
  SUB $F $F 01
  SET $F :VAR_INPUTCMDINDEX
  MOV $C $D :VAR_KEYCHAR
  JMP $F :FCT_PRINT
  JMP $F :FCT_CMD_LOOP

  # enter
  FCT_CMD_CR:
  # are we in debug mode ?
  GET $F :VAR_MODE
  CMP $F M_DEBUG
  JMP UEQ :FCT_DEBUG
  # are we in prompt mode ?
  GET $F :VAR_MODE
  CMP $F M_PROMPT
  JMP UEQ :FCT_PROMPT
  # are we in prog mode ?
  GET $F :VAR_MODE
  CMP $F M_PROG
  JMP UEQ :FCT_PROG
  FCT_CMD_CR_END:
  # reset input index
  SET :VAR_INPUTCMD:l
   :VAR_INPUTCMDINDEX
  # set input char
  SET K_CR :VAR_KEYCHAR
  # loop
  JMP $F :FCT_CMD_LOOP

 FCT_CMD_STRDEBUG:
 SET 07 :VAR_MAXCMDBUF
 MOV $C $D :STR_ENTERDEBUG
 JMP $F :FCT_PRINT
 JMP $F :FCT_CMD_INIT

 FCT_CMD_STRPROMPT:
 SET 07 :VAR_MAXCMDBUF
 MOV $C $D :STR_ENTERPROMPT
 JMP $F :FCT_PRINT
 JMP $F :FCT_CMD_INIT

 FCT_CMD_STRPROG:
 SET 00 :VAR_MAXCMDBUF
 SET :VAR_PROG_MEM:h
  :VAR_PROG_CURS
 SET :VAR_PROG_MEM:l
  :VAR_PROG_CURS_END
 MOV $C $D :STR_ENTERPROG
 JMP $F :FCT_PRINT
 JMP $F :FCT_CMD_INIT

 FCT_CMD_END:
 MOV $C $D :STR_EXIT
 JMP $F :FCT_PRINT
 # epilogue
 JMP $F :RT_POPABCDE
 JMP $F :RT_EPILOGUE


FCT_SCROLLUP:
 # prologue
 SET $J1 :VAR_CALL_H
 SET $J2 :VAR_CALL_L
 JMP $F :RT_PROLOGUE
 # push registers
 JMP $F :RT_PUSHABCDE
 MOV $A $G1
 JMP $F :SRT_PUSH # push $G1

 # init
 MOV $A :VRAM:h
 MOV $B 40
 MOV $E $G1 :VRAM

 FCT_SCROLLUP_LOOP:
  # is it the end ?
  MOV $C 25
  MOV $D 40
  JMP $F :RT_CMP16
  # then break
  JMP UEQ :FCT_SCROLLUP_END
  # else shift vram value
  FCT_SCROLLUP_VSYNC:
   JMP $F :RT_VSYNC
   GET $F $A $B
   SET $F $E $G1
   # check if vsync still on
   GET $F :VPU_STATE
   AND $F $F 01
   CMP $F 00
   AND $F $F 04
   # then continue
   JMP 00 :FCT_SCROLLUP_LOOP_NXT
   # else retry
   JMP $F :FCT_SCROLLUP_VSYNC
  FCT_SCROLLUP_LOOP_NXT:
  # inc AB
  JMP $F :RT_INC16
  # inc EG1
  MOV $C $A
  MOV $D $B
  MOV $A $E
  MOV $B $G1
  JMP $F :RT_INC16
  MOV $E $A
  MOV $G1 $B
  MOV $A $C
  MOV $B $D
  # loop
  JMP $F :FCT_SCROLLUP_LOOP

 FCT_SCROLLUP_END:
 # pop registers
 JMP $F :SRT_POP # pop $G1
 MOV $G1 $A
 JMP $F :RT_POPABCDE
 # epilogue
 JMP $F :RT_EPILOGUE


#
FCT_DEBUG:
 # prologue
 SET $J1 :VAR_CALL_H
 SET $J2 :VAR_CALL_L
 JMP $F :RT_PROLOGUE
 JMP $F :RT_PUSHABCDE

 # init
 SUB $C :VAR_INPUTCMDSTOP:l 08
 MOV $E :VAR_DBGCMD_OP_END:l

 # loop
 FCT_DEBUG_LOOP:
  SUB $F :VAR_DBGCMD_OP:l 01
  CMP $E $F
  JMP UEQ :FCT_DEBUG_END

  GET $A :VAR_INPUTCMD:h $C
  SET K_0 :VAR_INPUTCMD:h $C
  SUB $C $C 01
  JMP $F :RT_HEXTOVAL
  MOV $D $A
  GET $A :VAR_INPUTCMD:h $C
  SET K_0 :VAR_INPUTCMD:h $C
  SUB $C $C 01
  JMP $F :RT_HEXTOVAL
  MUL $A $A 10
  ADD $A $A $D
  SET $A :VAR_DBGCMD_OP:h $E
  
  SUB $E $E 01
  JMP $F :FCT_DEBUG_LOOP

 FCT_DEBUG_END:
 JMP $F :VAR_DBGCMD_OP
 # print line feed
 SET K_LF :VAR_KEYCHAR
 MOV $C $D :VAR_KEYCHAR
 JMP $F :FCT_PRINT
 # epilogue
 JMP $F :RT_POPABCDE
 JMP $F :RT_EPILOGUE

#
FCT_PROMPT:
 # prologue
 SET $J1 :VAR_CALL_H
 SET $J2 :VAR_CALL_L
 JMP $F :RT_PROLOGUE
 JMP $F :RT_PUSHABCDE

 # get input cmd
 GET $F :VAR_INPUTCMDINDEX
 SET 00 :VAR_INPUTCMD:h $F
 MOV $C $D :VAR_INPUTCMD

 FCT_PROMPT_STOP:
 # get stop str
 MOV $A $B :STR_STOP
 # cmp str
 JMP $F :RT_CMPSTR
 CMP $A 00
 JMP UEQ :FCT_PROMPT_DEBUG
 OFF

 FCT_PROMPT_DEBUG:
 # get debug str
 MOV $A $B :STR_DEBUG
 # cmp str
 JMP $F :RT_CMPSTR
 CMP $A 00
 JMP UEQ :FCT_PROMPT_PROG
 SET M_DEBUG :VAR_MODE
 JMP $F :FCT_CMD
 SET M_PROMPT :VAR_MODE
 JMP $F :FCT_PROMPT_END

 FCT_PROMPT_PROG:
 # get debug str
 MOV $A $B :STR_PROG
 # cmp str
 JMP $F :RT_CMPSTR
 CMP $A 00
 JMP UEQ :FCT_PROMPT_NOCMD
 SET M_PROG :VAR_MODE
 JMP $F :FCT_CMD
 SET M_PROMPT :VAR_MODE
 JMP $F :FCT_PROMPT_END

 FCT_PROMPT_NOCMD:
 MOV $C $D :STR_NOCMD
 JMP $F :FCT_PRINT

 FCT_PROMPT_END:
 # print prompt
 MOV $C $D :STR_PROMPT
 JMP $F :FCT_PRINT
 # epilogue
 JMP $F :RT_POPABCDE
 JMP $F :RT_EPILOGUE


#
FCT_PROG:
 # prologue
 SET $J1 :VAR_CALL_H
 SET $J2 :VAR_CALL_L
 JMP $F :RT_PROLOGUE
 JMP $F :RT_PUSHABCDE
 MOV $A $G0
 JMP $F :SRT_PUSH
 MOV $A $G1
 JMP $F :SRT_PUSH

 # end the input cmd string
 # just in case
 GET $F :VAR_INPUTCMDINDEX
 SET 00 :VAR_INPUTCMD:h $F
 ADD $F :VAR_INPUTCMD:l 03
 SET 00 :VAR_INPUTCMD:h $F

 MOV $A $B :VAR_INPUTCMD
 JMP $F :FCT_STRTOREG
 MOV $G5 $A
 #MOV $C $D :VAR_INPUTCMD
 #JMP $F :FCT_STRTOVAL
 #MOV $G4 $C

 # get first instruction str
 MOV $C $D :STR_INS

 MOV $E 00


 FCT_PROG_INS:
  # check if we are at the end
  # of possible str
  MOV $A $B :STR_INS_END
  JMP $F :RT_CMP16
  JMP UEQ :FCT_PROG_ERROR
  MOV $G0 $C
  MOV $G1 $D
  # get input cmd
  MOV $A $B :VAR_INPUTCMD
  # cmp str
  JMP $F :RT_CMPSTR
  CMP $A 01
  JMP UEQ :FCT_PROG_FIND
  # next str
  MOV $C $G0
  MOV $D $G1
  MOV $A 00
  MOV $B 04
  JMP $F :RT_ADD16
  MOV $C $A
  MOV $D $B
  ADD $E $E 01
  # loop
  JMP $F :FCT_PROG_INS
 
 FCT_PROG_FIND:
 MOV $C 00
 MOV $D $E
 MOV $A $B :DT_INS_BASECODE
 JMP $F :RT_ADD16
 GET $D $A $B
 SET $D :VAR_DBGCMD_OP

 CMP $D 03
 AND $F $F 01
 JMP 00 :FCT_PROG_NOARG
 CMP $D 10
 AND $F $F 01
 JMP 00 :FCT_PROG_TWOARG
 CMP $D 50
 AND $F $F 01
 JMP 00 :FCT_PROG_THREEARG
 CMP $D FE
 AND $F $F 01
 JMP 00 :FCT_PROG_MEMARG
 JMP $F :FCT_PROG_META


 FCT_PROG_NOARG:
 ADD $F :VAR_DBGCMD_OP:l 01
 SET 00 :VAR_DBGCMD_OP:h $F
 ADD $F $F 01
 SET 00 :VAR_DBGCMD_OP:h $F
 ADD $F $F 01
 SET 00 :VAR_DBGCMD_OP:h $F
 JMP $F :FCT_PROG_SAVE

 FCT_PROG_TWOARG:
 # check if mov
 CMP $D 03
 JMP UEQ :FCT_PROG_MOV
 # set op2 to 0
 ADD $F :VAR_DBGCMD_OP:l 01
 SET 00 :VAR_DBGCMD_OP:h $F
 #
 MOV $C 04
 MOV $D 01
 MOV $E 02
 JMP $F :FCT_OPREGVAL
 # 
 MOV $C 08
 MOV $D 02
 MOV $E 03
 JMP $F :FCT_OPREGVAL
 #
 JMP $F :FCT_PROG_SAVE

 FCT_PROG_MOV:
 # set op4 to 0
 ADD $F :VAR_DBGCMD_OP:l 03
 SET 00 :VAR_DBGCMD_OP:h $F
 #
 MOV $C 04
 MOV $D 00
 MOV $E 01
 JMP $F :FCT_OPREGVAL
 # 
 MOV $C 08
 MOV $D 01
 MOV $E 02
 JMP $F :FCT_OPREGVAL
 # 
 JMP $F :FCT_PROG_SAVE

 FCT_PROG_THREEARG:
 # 
 MOV $C 04
 MOV $D 00
 MOV $E 01
 JMP $F :FCT_OPREGVAL
 # 
 MOV $C 08
 MOV $D 10
 MOV $E 02
 JMP $F :FCT_OPREGVAL
 # 
 MOV $C 0C
 MOV $D 20
 MOV $E 03
 JMP $F :FCT_OPREGVAL
 # 
 JMP $F :FCT_PROG_SAVE

 FCT_PROG_MEMARG:
 CMP $D 60
 JMP UEQ :FCT_PROG_GET
 #
 MOV $C 04
 MOV $D 04
 MOV $E 01
 JMP $F :FCT_OPREGVAL
 # 
 JMP $F :FCT_PROG_MEMARGNXT

 FCT_PROG_GET:
 #
 MOV $C 04
 MOV $D 00
 MOV $E 01
 JMP $F :FCT_OPREGVAL

 FCT_PROG_MEMARGNXT:
 #
 MOV $C 08
 MOV $D 01
 MOV $E 02
 JMP $F :FCT_OPREGVAL
 #
 MOV $C 0C
 MOV $D 02
 MOV $E 03
 JMP $F :FCT_OPREGVAL
 JMP $F :FCT_PROG_SAVE

 FCT_PROG_META:
 # check if run
 CMP $D FF
 JMP UEQ :FCT_PROG_RUN
 # set op4 to 0
 ADD $F :VAR_DBGCMD_OP:l 03
 SET 00 :VAR_DBGCMD_OP:h $F
 #
 MOV $C 04
 MOV $D 00
 SUB $E :VAR_PROG_CURS:l
  :VAR_DBGCMD_OP:l
 JMP $F :FCT_OPREGVAL
 # 
 MOV $C 08
 MOV $D 00
 SUB $E :VAR_PROG_CURS_END:l
  :VAR_DBGCMD_OP:l
 JMP $F :FCT_OPREGVAL
 # 
 JMP $F :FCT_PROG_END

 FCT_PROG_RUN:
 #
 MOV $A $B :FCT_PROG
 MOV $C $D :VAR_PROG_MEM_START
 MOV $E 10
 JMP $F :RT_COPYMEM
 #
 MOV $A $B :FCT_PROG_RET
 MOV $C $D :VAR_PROG_MEM_END
 MOV $E 08
 JMP $F :RT_COPYMEM
 #
 JMP $F :VAR_PROG_MEM_START
 #
 JMP $F :FCT_PROG_END


 FCT_PROG_SAVE:
 GET $A :VAR_PROG_CURS
 GET $B :VAR_PROG_CURS_END
 MOV $C $D :VAR_PROG_MEM_END
 JMP $F :RT_CMP16
 JMP UEQ :FCT_PROG_FULL
 #
 GET $F :VAR_DBGCMD_OP1
 SET $F $A $B
 JMP $F :RT_INC16
 #
 GET $F :VAR_DBGCMD_OP2
 SET $F $A $B
 JMP $F :RT_INC16
 #
 GET $F :VAR_DBGCMD_OP3
 SET $F $A $B
 JMP $F :RT_INC16
 #
 GET $F :VAR_DBGCMD_OP4
 SET $F $A $B
 JMP $F :RT_INC16
 #
 SET $A :VAR_PROG_CURS
 SET $B :VAR_PROG_CURS_END
 JMP $F :FCT_PROG_END

 FCT_PROG_FULL:
 MOV $C $D :STR_PROGFULL
 JMP $F :FCT_PRINT
 JMP $F :FCT_PROG_END

 FCT_PROG_ERROR:
 MOV $C $D :STR_ERROR
 JMP $F :FCT_PRINT

 FCT_PROG_END:
 # print line feed
 SET K_LF :VAR_KEYCHAR
 MOV $C $D :VAR_KEYCHAR
 JMP $F :FCT_PRINT
 # print prompt
 MOV $C $D :STR_PROMPT
 JMP $F :FCT_PRINT
 # epilogue
 JMP $F :SRT_POP
 MOV $G1 $A
 JMP $F :SRT_POP
 MOV $G0 $A
 FCT_PROG_RET:
 JMP $F :RT_POPABCDE
 JMP $F :RT_EPILOGUE


# C D E
FCT_OPREGVAL:
 # prologue
 SET $J1 :VAR_CALL_H
 SET $J2 :VAR_CALL_L
 JMP $F :RT_PROLOGUE
 JMP $F :RT_PUSHABCDE

 # check reg
 MOV $A :VAR_INPUTCMD:h
 ADD $B :VAR_INPUTCMD:l $C
 JMP $F :FCT_STRTOREG
 CMP $A FF
 JMP UEQ :FCT_OPREGVAL_VAL
 JMP $F :FCT_OPREGVAL_END
 FCT_OPREGVAL_VAL:
 MOV $B $D
 ADD $D :VAR_INPUTCMD:l $C
 MOV $C :VAR_INPUTCMD:h
 JMP $F :FCT_STRTOVAL
 MOV $A $C
 # inc ins val
 GET $F :VAR_DBGCMD_OP
 ADD $F $F $B
 SET $F :VAR_DBGCMD_OP

 FCT_OPREGVAL_END:
 # set opcode
 ADD $F :VAR_DBGCMD_OP:l $E
 SET $A :VAR_DBGCMD_OP:h $F
 # epilogue
 JMP $F :RT_POPABCDE
 JMP $F :RT_EPILOGUE



# PARAM: AB=adr
FCT_STRTOREG:
 # prologue
 SET $J1 :VAR_CALL_H
 SET $J2 :VAR_CALL_L
 JMP $F :RT_PROLOGUE

 GET $F $A $B
 CMP $F K_$
 AND $F $F 04
 JMP 00 :FCT_STRTOREG_NOP

 JMP $F :RT_INC16
 GET $J1 $A $B
 CMP $J1 K_O
 JMP UEQ :FCT_STRTOREG_O
 CMP $J1 K_A
 JMP UEQ :FCT_STRTOREG_A
 CMP $J1 K_B
 JMP UEQ :FCT_STRTOREG_B
 CMP $J1 K_C
 JMP UEQ :FCT_STRTOREG_C
 CMP $J1 K_D
 JMP UEQ :FCT_STRTOREG_D
 CMP $J1 K_E
 JMP UEQ :FCT_STRTOREG_E
 CMP $J1 K_F
 JMP UEQ :FCT_STRTOREG_F
 CMP $J1 K_R
 JMP UEQ :FCT_STRTOREG_R
 CMP $J1 K_J
 JMP UEQ :FCT_STRTOREG_J
 CMP $J1 K_G
 JMP UEQ :FCT_STRTOREG_G

 FCT_STRTOREG_NOP:
 MOV $A FF
 JMP $F :FCT_STRTOREG_END
 FCT_STRTOREG_O:
 MOV $A 00
 JMP $F :FCT_STRTOREG_END
 FCT_STRTOREG_A:
 MOV $A 01
 JMP $F :FCT_STRTOREG_END
 FCT_STRTOREG_B:
 MOV $A 02
 JMP $F :FCT_STRTOREG_END
 FCT_STRTOREG_C:
 MOV $A 03
 JMP $F :FCT_STRTOREG_END
 FCT_STRTOREG_D:
 MOV $A 04
 JMP $F :FCT_STRTOREG_END
 FCT_STRTOREG_E:
 MOV $A 05
 JMP $F :FCT_STRTOREG_END
 FCT_STRTOREG_F:
 MOV $A 06
 JMP $F :FCT_STRTOREG_END
 FCT_STRTOREG_R:
 MOV $A 07
 JMP $F :FCT_STRTOREG_END

 FCT_STRTOREG_J:
 JMP $F :RT_INC16
 GET $J1 $A $B
 CMP $J1 K_1
 JMP UEQ :FCT_STRTOREG_J1
 CMP $J1 K_2
 JMP UEQ :FCT_STRTOREG_J2
 JMP $F :FCT_STRTOREG_NOP
 FCT_STRTOREG_J1:
 MOV $A 08
 JMP $F :FCT_STRTOREG_END
 FCT_STRTOREG_J2:
 MOV $A 09
 JMP $F :FCT_STRTOREG_END

 FCT_STRTOREG_G:
 JMP $F :RT_INC16
 GET $J1 $A $B
 CMP $J1 K_0
 JMP UEQ :FCT_STRTOREG_G0
 CMP $J1 K_1
 JMP UEQ :FCT_STRTOREG_G1
 CMP $J1 K_2
 JMP UEQ :FCT_STRTOREG_G2
 CMP $J1 K_3
 JMP UEQ :FCT_STRTOREG_G3
 CMP $J1 K_4
 JMP UEQ :FCT_STRTOREG_G4
 CMP $J1 K_5
 JMP UEQ :FCT_STRTOREG_G5
 JMP $F :FCT_STRTOREG_NOP
 FCT_STRTOREG_G0:
 MOV $A 0A
 JMP $F :FCT_STRTOREG_END
 FCT_STRTOREG_G1:
 MOV $A 0B
 JMP $F :FCT_STRTOREG_END
 FCT_STRTOREG_G2:
 MOV $A 0C
 JMP $F :FCT_STRTOREG_END
 FCT_STRTOREG_G3:
 MOV $A 0D
 JMP $F :FCT_STRTOREG_END
 FCT_STRTOREG_G4:
 MOV $A 0E
 JMP $F :FCT_STRTOREG_END
 FCT_STRTOREG_G5:
 MOV $A 0F
 JMP $F :FCT_STRTOREG_END

 FCT_STRTOREG_END:
 JMP $F :RT_EPILOGUE


# PARAM: CD
FCT_STRTOVAL:
 # prologue
 SET $J1 :VAR_CALL_H
 SET $J2 :VAR_CALL_L
 JMP $F :RT_PROLOGUE
 JMP $F :SRT_PUSH
 MOV $A $B
 JMP $F :SRT_PUSH
 MOV $A $E
 JMP $F :SRT_PUSH

 GET $A $C $D
 JMP $F :RT_HEXTOVAL
 MOV $E $A
 MOV $A $C
 MOV $B $D
 JMP $F :RT_INC16
 GET $A $A $B
 JMP $F :RT_HEXTOVAL
 MUL $E $E 10
 ADD $C $A $E

 FCT_STRTOVAL_END:
 JMP $F :SRT_POP
 MOV $E $A
 JMP $F :SRT_POP
 MOV $B $A
 JMP $F :SRT_POP
 JMP $F :RT_EPILOGUE


